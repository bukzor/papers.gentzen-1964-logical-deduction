#!/usr/bin/env python3
"""Split lines at specified column positions.

Usage: split-line-at FILE LINE:COLUMN [LINE:COLUMN ...]

Splits at the specified column (copy markers from find-merged-lines output).
Reads FILE and writes to stdout.

Example:
    split-line-at 289.txt 2:49 28:48 29:51 > 289-fixed.txt
"""

import sys


def parse_split_specs(specs):
    """Parse list of 'LINE:COLUMN' or '<LINE:COLUMN>' into dict {line_num: column}."""
    splits = {}
    for spec in specs:
        # Strip angle brackets if present
        spec = spec.strip('<>')
        parts = spec.split(':')
        if len(parts) != 2:
            print(f"Invalid split spec: {spec}, expected LINE:COLUMN", file=sys.stderr)
            sys.exit(1)
        line_num = int(parts[0])
        column = int(parts[1])
        splits[line_num] = column
    return splits


def main():
    if len(sys.argv) < 3:
        print(__doc__, file=sys.stderr)
        sys.exit(1)

    filename = sys.argv[1]
    split_specs = parse_split_specs(sys.argv[2:])

    had_errors = False

    with open(filename) as f:
        for line_num, line in enumerate(f, start=1):
            line = line.rstrip('\n')

            if line_num in split_specs:
                column = split_specs[line_num]
                if len(line) <= column:
                    print(f"Error: Line {line_num} too short (len={len(line)}) to split at column {column}", file=sys.stderr)
                    print(line)
                    had_errors = True
                elif line[column] != ' ':
                    print(f"Error: Line {line_num} column {column} is not a space: {line[column]!r}", file=sys.stderr)
                    print(line)
                    had_errors = True
                else:
                    left = line[:column]
                    right = line[column+1:]
                    print(left)
                    print(right)
            else:
                print(line)

    if had_errors:
        sys.exit(1)


if __name__ == '__main__':
    main()
